import common.properties
import common.rider.rdLibDirectory
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

@Suppress(
    //see: https://youtrack.jetbrains.com/issue/KTIJ-19369
    "DSL_SCOPE_VIOLATION"
)
plugins {
    id("plugin-library")
    id("common-kotlin")
    id("com.jetbrains.rdgen") version libs.versions.rider.rdgen.get()
}


dependencies {
    compileOnly(project(":model"))
    compileOnly(project(":ide-common"))
}



intellij {
    version.set("RD-"+ properties("platformVersion",project))
    plugins.set(listOf("rider-plugins-appender"))
    downloadSources.set(false) //there are no sources for rider
    instrumentCode.set(false) // why not??
}




tasks {

    properties("javaVersion", project).let {
        withType<JavaCompile> {
            dependsOn(named("rdgen"))
            options.release.set(it.toInt())
        }
        withType<KotlinCompile> {
            dependsOn(named("rdgen"))
            kotlinOptions.jvmTarget = it
        }
    }


    val setBuildTool = create("setBuildTool") {
        doLast {
            val toolArgs = ArrayList<String>()
            extra["executable"] = "dotnet"
            toolArgs.add("msbuild")
            toolArgs.add(properties("DotnetPluginId", project) + "/" + properties("DotnetSolution", project))
            toolArgs.add("/p:Configuration=" + properties("BuildConfiguration", project))
            toolArgs.add("/p:HostFullIdentifier=")

            extra["args"] = toolArgs.toTypedArray()
        }

    }


    val compileDotNet = create("compileDotNet") {
        dependsOn(named("setBuildTool"))
        dependsOn(named("rdgen"))
        doLast {
            val arguments: MutableList<String> = (setBuildTool.extra.get("args") as Array<String>).toMutableList()
            arguments.add("/t:Restore;Rebuild")
            exec {
                executable = setBuildTool.extra.get("executable").toString()
                args = arguments
                workingDir = projectDir
            }
        }
    }


    //rider contributes the dlls to the main project's sandbox
    val prepareSandboxForRider = create("prepareSandboxForRider", Sync::class.java) {
        dependsOn(compileDotNet)
        mustRunAfter(project.rootProject.tasks.getByName("prepareSandbox"))

        val dllOutputFolder = "${projectDir}/Digma.Rider.Plugin/Digma.Rider/bin/Digma.Rider/Debug/"
        val dllFiles = listOf(
            "$dllOutputFolder/Digma.Rider.dll",
            "$dllOutputFolder/Digma.Rider.pdb"
        )


        val sandboxDotnetDir = project.rootProject.layout.buildDirectory.dir("idea-sandbox").get().dir("plugins")
            .dir(properties("pluginName", project)).dir("dotnet")

        sandboxDotnetDir.asFile.mkdirs()

        dllFiles.forEach {
            val file = file(it)
            logger.lifecycle("found dotnet object: $file")
            from(file)
        }
        into(sandboxDotnetDir)

        doLast {
            dllFiles.forEach {
                val file = file(it)
                if (!file.exists()) throw GradleException("file $file does not exist")
            }
        }
    }

    prepareSandbox {
        dependsOn(prepareSandboxForRider)
    }

    buildPlugin{
        mustRunAfter(prepareSandboxForRider)
    }


    //the file rider.kotlin_module is generated by kotlin and as i noticed in rider plugin template it is
    //packaged into the plugin. couldn't understand if this file is necessary or not and even jetbrains guys
    //couldn't tell what it is. it's in every rider plugin i saw, so copy this file to our main plugin whatever it is.
    create("copyKotlinModuleFile",Copy::class.java){
        dependsOn(classes)
        from(project.layout.buildDirectory.dir("classes/kotlin/main/META-INF").get().file("rider.kotlin_module"))
        into(project.rootProject.layout.buildDirectory.dir("resources/main/META-INF"))
    }


    clean{
        delete("${projectDir}/Digma.Rider.Plugin/Digma.Rider/bin")
        delete("${projectDir}/Digma.Rider.Plugin/Digma.Rider/obj")
        delete("${projectDir}/Digma.Rider.Plugin/Digma.Rider.Tests/bin")
        delete("${projectDir}/Digma.Rider.Plugin/Digma.Rider.Tests/obj")
    }
}


//todo: create a clean task to clean what rdgen generates
rdgen {

//    val DotnetPluginId = properties("DotnetPluginId",project)
//    val RiderPluginId = properties("RiderPluginId",project).replace('.','/').toLowerCase()
    val modelDir = File(projectDir, "protocol/src/main/kotlin")
    val csOutput = File(projectDir, "Digma.Rider.Plugin/Digma.Rider/Protocol")
    val ktOutput = File(projectDir, "src/main/kotlin/org/digma/intellij/plugin/rider/protocol")

    verbose = true
    classpath(rdLibDirectory(project).canonicalPath + "/rider-model.jar")
    logger.lifecycle("rdLibDirectory is ${rdLibDirectory(project).canonicalPath}")
    sources("${modelDir.canonicalPath}/rider/model")
    hashFolder = buildDir.canonicalPath
    packages = "rider.model"

    generator {
        language = "kotlin"
        transform = "asis"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "org.digma.rider.protocol"
        directory = ktOutput.canonicalPath
    }

    generator {
        language = "csharp"
        transform = "reversed"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "Digma.Rider.Protocol"
        directory = csOutput.canonicalPath
    }
}